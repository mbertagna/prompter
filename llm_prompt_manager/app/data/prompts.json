[
  {
    "title": "Coding Agent Prompt Creation",
    "description": "A prompt which can be provided to a LLM-based chatbot which has context about a feature to implement. The result of providing this prompt to the chatbot can be passed to a coding agent (e.g., Cursor, Gemini CLI, Claude Code, etc.).",
    "base_prompt": "Implement the specified feature into the codebase. **Focus on conceptual clarity and overall architectural integration**, leaving granular implementation choices and specific low-level logic (e.g., helper functions, specific variable names beyond essential ones) to your discretion. **Avoid providing overly specific implementation details** that limit your freedom, unless absolutely necessary for correct integration.\n\nYour response must strictly adhere to the following structure and content requirements:\n\n### 1. Feature Overview\n\nProvide a **clear and concise conceptual overview** of the feature's purpose, scope, and expected user value.\n\n### 2. Conceptual Breakdown of Codebase Changes (Without Code)\n\nProvide a **comprehensive, high-level conceptual breakdown** of all necessary changes to integrate the feature into the existing codebase structure. This must detail the conceptual roles of new classes, methods, or functions, and which existing components they will interact with or modify. **Avoid writing or suggesting specific code implementation details.** Focus on *what* needs to be done and *where* it fits conceptually.\n\n### 3. Architectural Alignment and Guidance\n\nOffer **specific, high-level guidance** on how these changes align with, and respect, the current architecture (e.g., adherence to design patterns, module separation, data flow conventions). **Emphasize modularity**\u2014each conceptual function should perform a specific, single task.\n\n---\n\n### General Coding Style and Deliverables\n\nAdhere to the following style guidelines in the implemented code:\n\n* **Docstrings:** Use **NumPy docstring format** for all classes, methods, and functions where applicable. Ensure the verbiage is **concise**.\n* **Comments:** **Remove all unnecessary comments.** Only include comments for non-obvious, complex logic if absolutely required for understanding.\n* **Modularity:** Ensure the code is highly modular; each function/method must perform a **specific, single task**.\n* **Emojis:** Avoid the use of emojis.\n\n---\n\n### Context Files\n\nThe following files will be provided as context for accurate and efficient implementation:\n\n* [List of all necessary files (e.g., `src/module_a/file.py`, `tests/test_file.py`, etc.)]",
    "parameters": [],
    "id": "a9410a06-1b44-4fbc-9e26-9e8426faaa4b"
  },
  {
    "title": "Project Spec Builder",
    "description": "A chatbot prompt which can be used to help create a spec for any software project",
    "base_prompt": "**Idea Overview:**\nI want to build a software project that { {{PROJECT_IDEA}} }.\n\n---\n\n### **Areas to Explore**\n\nBefore creating a detailed specification, I need to understand the following:\n\n* **Purpose and scope** \u2014 what the project should accomplish and who it\u2019s for\n* **Core functionality** \u2014 the main features and capabilities\n* **Technology preferences** \u2014 programming languages, frameworks, tools, or platforms to use\n* **Architecture and infrastructure** \u2014 how components interact, data flow, hosting, and deployment\n* **Integration needs** \u2014 any external systems, APIs, or data sources to connect with\n* **User interaction and interface** \u2014 how users will interact with the system (CLI, GUI, web app, API, etc.)\n* **Performance and scalability** \u2014 expected load, performance goals, and scaling considerations\n* **Security and privacy requirements** \u2014 any specific standards, data protection, or authentication needs\n* **Testing and maintenance** \u2014 expectations for testing, monitoring, or long-term upkeep\n\n---\n\n### **Your Task**\n\n#### **Phase 1: Discovery (Before Building the Specification)**\n\n* Ask **yes/no questions one at a time** to gather information about each of the areas above.\n* **Wait for the user\u2019s response** before asking the next question.\n* Do **not** create or outline the specification yet.\n* When you believe you\u2019ve gathered sufficient details, **propose that you have enough information** and ask the user to confirm before proceeding.\n* Only move to Phase 2 if the user **explicitly agrees** that you have enough information.\n\n#### **Phase 2: Specification (After User Agreement)**\n\n* Create the specification **only after** receiving explicit user confirmation.\n* Do **not** mix questioning with specification writing.\n* Write a **concise, detailed, and structured specification** that accurately reflects all information gathered during Phase 1.\n",
    "parameters": [
      "PROJECT_IDEA"
    ],
    "id": "f3974a6c-3524-4afb-9738-4c1ff01c7f34"
  },
  {
    "title": "Coding Agent Prompt Creation for New Codebase Architecture",
    "description": "",
    "base_prompt": "**Codebase:** { {{CODEBASE}} }\n\n# **Your Goal:** Design a modular, DRY, and scalable organization structure for upcoming feature integrations.\n\n---\n\n### Primary Objective\n\nYou are tasked with proposing **codebase organization options** for [CODEBASE_NAME_PLACEHOLDER] one at a time.\nEach proposal should aim for **maximal modularity, clarity, and architectural consistency** with the presumed or provided structure of the codebase.\n\nAt each iteration:\n\n1. Provide **one** option for organization (not multiple at once).\n2. Wait for my feedback.\n3. If I request changes or refinements, incorporate them into the next iteration.\n4. When I explicitly approve an option, you will then generate a **final implementation prompt** for a coding agent as described below.\n\n---\n\n### Step 1: Iterative Codebase Organization Proposal\n\nEach proposal should include:\n\n#### 1. Conceptual Structure Overview\n\nProvide a **concise conceptual map** of how the system\u2019s architecture and components will be restructured or reorganized.\nExplain the purpose of each new or refactored module, class, or directory and how they fit into the broader design.\n\n#### 2. Key Modules and Responsibilities\n\nList the **key components** (modules, classes, or functions) and describe their **high-level conceptual roles** \u2014 what each does and how they interact \u2014 **without suggesting any specific implementation or code**.\n\n#### 3. Design Rationale\n\nJustify **why** this architectural approach improves modularity, reusability, maintainability, and scalability.\nReference design principles (e.g., SOLID, separation of concerns, dependency inversion) where appropriate.\n\n#### 4. DRYness and Extensibility Check\n\nExplicitly explain how the proposed structure:\n\n* Eliminates redundancy and tight coupling\n* Supports extensibility and maintainability\n* Aligns with or improves upon the codebase\u2019s existing patterns and conventions\n\nAfter presenting this, stop and ask:\n\n> \u201cWould you like to approve this organization or request revisions before proceeding?\u201d\n\n---\n\n### Step 2: Once Approved \u2014 Generate the Implementation Prompt\n\nWhen I approve a structure, you will output the following **final implementation prompt** (filled in appropriately):\n\n---\n\n#### **Implementation Prompt for Coding Agent**\n\n**Prompt:**\n\n> Implement the approved architectural restructuring in the codebase.\n> **Focus on conceptual clarity, structural integrity, and modular organization**, leaving detailed implementation choices and low-level logic (e.g., helper utilities, variable names, or internal optimizations) to your discretion.\n> **Avoid overly specific implementation details** unless they are essential to preserve architectural correctness.\n\nYour response must strictly adhere to the following structure and content requirements:\n\n---\n\n### 1. Architectural Restructure Overview\n\nProvide a **clear and concise conceptual overview** of the architectural restructuring \u2014 its purpose, motivation, and expected impact on the codebase (e.g., improved modularity, maintainability, or scalability).\n\n### 2. Conceptual Breakdown of Changes (Without Code)\n\nProvide a **comprehensive, high-level conceptual breakdown** of the restructuring steps.\nDescribe which components, modules, or directories are being added, removed, or reorganized, and how they interact in the new structure.\n**Avoid suggesting specific code.** Focus on *what* needs to change and *where* it fits conceptually.\n\n### 3. Architectural Alignment and Guidance\n\nOffer **specific, high-level guidance** on how the restructuring aligns with and strengthens the existing architecture (e.g., enforcing separation of concerns, design patterns, or layering principles).\n**Emphasize modularity** \u2014 each module or class should have a single, well-defined purpose.\n\n---\n\n### General Coding Style and Deliverables\n\nAdhere to the following style guidelines in the restructured code:\n\n* **Docstrings:** Use **NumPy docstring format** for all classes, methods, and functions where applicable. Ensure the verbiage is **concise**.\n* **Comments:** **Remove all unnecessary comments.** Only include comments for complex, non-obvious logic if absolutely required for clarity.\n* **Modularity:** Ensure the architecture enforces strong modular boundaries \u2014 each component should perform a **specific, single role**.\n* **Emojis:** Avoid the use of emojis.\n\n---\n\n### Context Files\n\nThe following files will be provided as context for accurate and efficient restructuring:\n\n* [List of all necessary files (e.g., `src/module_a/file.py`, `core/architecture.py`, `tests/test_integration.py`, etc.)]\n\n---\n\n### Step 3: Iterative Refinement (Optional)\n\nIf requested, you may help refine or adapt the generated implementation prompt (e.g., adjusting restructuring scope, architecture focus, or file list) before it is finalized for the coding agent.\n",
    "parameters": [
      "CODEBASE"
    ],
    "id": "b4e84abe-0bbe-48ba-b037-10417ddab48f"
  },
  {
    "title": "Commit Prompt",
    "description": "",
    "base_prompt": "Create a commit message that follows exactly the same format and structure as the provided example.\nUse **simple, clear language** and keep all bullet points short and direct.\nAvoid changing any section headers, indentation, or layout \u2014 your goal is to match the style of the example exactly.\nAvoid using any markdown formatting such as bold text, code blocks, or lists. Use plain text only.\nReturn the final commit message **inside a text box**.\n\nExample commit message:\n{ {{example_commit_message}} }\n\nImplementation summary:\n{ {{implementation_summary}} }\n\nImplementation code:\n{ {{implementation_code}} }",
    "parameters": [
      "example_commit_message",
      "implementation_summary",
      "implementation_code"
    ],
    "id": "2f3eda1a-48f8-460a-b9e7-3b1801c1df0b"
  },
  {
    "title": "Atomic Git History Generation (Interactive)",
    "description": "A three-stage, approval-gated workflow to transform a single, large code change (before/after diff) into a clean, logical set of atomic commits organized across ordered topic branches. This strategy supports a clean, rebasable dependency tree.",
    "base_prompt": "I have made changes to the **{{TOPIC}}** project. My goal is to organize these changes into a clean, logical set of **atomic Git commits** across multiple **topic branches** for a final push.\n\nYour process will consist of three distinct tasks, each requiring my approval before proceeding to the next.\n\n### Task 1: Code Difference Analysis\n\n1.  **Analyze the changes:** Review the `CODE_BEFORE` and `CODE_AFTER` sections to understand the exact differences in the codebase.\n2.  **Report findings:** Summarize the nature and scope of the changes (e.g., \"Feature X added,\" \"Refactoring of Y module,\" \"Bug Z fixed\").\n3.  **Output:** Present a summary of the differences.\n      * **STOP:** Wait for my approval before proceeding to Task 2. I may ask for revisions or clarifications at this stage.\n\n-----\n\n### Task 2: High-Level Git Organization\n\n  * *This task proceeds only after my approval of Task 1.*\n\n1.  **Determine topics:** Group the changes identified in Task 1 into logical, high-level **topic branches** (e.g., `feature/user-auth`, `refactor/api-cleanup`).\n2.  **Establish ordering:** Decide on the most logical and narrative **ordering** for these topic branches, ensuring a clean dependency tree where each branch builds on the previous one.\n3.  **Output:** Provide a numbered list of the proposed topic branches and their intended order.\n      * **STOP:** Wait for my approval before proceeding to Task 3. I may ask for revisions to the branch structure or ordering.\n\n-----\n\n### Task 3: Atomic Commit Generation\n\n  * *This task proceeds only after my approval of Task 2.*\n\n1.  **Generate atomic commits:** For each approved topic branch, break down the changes into the smallest possible **atomic commits**. The commits must be ordered to tell a clear, logical story.\n2.  **Format the output:** For each generated atomic commit, present two items:\n      * A **one-line commit summary** (max 50 characters).\n      * A list of the specific **files or code snippets** to be included in that commit (i.e., the diff to be staged). Clearly indicate which topic branch the commit belongs to.\n3.  **Dependency Note:** I will be rebasing each successive new topic branch onto the previous one. The commit structure *must* support this clean, sequential dependency tree.\n\n-----\n\n## Code Base\n\nCODE BEFORE:\n{ {{CODE_BEFORE}} }\n\nCODE AFTER:\n{ {{CODE_AFTER}} }",
    "parameters": [
      "TOPIC",
      "CODE_BEFORE",
      "CODE_AFTER"
    ],
    "id": "f22f36c0-f0c7-4d82-ac9a-c474e6afcfec"
  },
  {
    "title": "Add NumPy-Style Docstrings Without Modifying Code",
    "description": "",
    "base_prompt": "Add complete and correct NumPy-style docstrings to the provided code.\n\nFollow these exact rules carefully:\n\n1. **File-level docstring:** At the very top of each file, include a brief description of the file\u2019s purpose, main classes/functions, and any important usage notes.\n2. **Class docstrings:** Describe what the class represents, its main attributes, and its intended use. Include an **Attributes** section listing all key attributes and their types.\n3. **Function and method docstrings:** Include the following NumPy-style sections where applicable:\n   * **Parameters:** List every parameter, its type, and a short, clear explanation.\n   * **Returns:** Describe the return value(s) and their types.\n   * **Raises:** List possible exceptions, if any.\n   * **Examples:** Add a simple example only if it helps clarify functionality.\n4. Use **simple, direct, and concise** language throughout.\n5. **Avoid emojis** and unnecessary phrasing.\n6. **Avoid changing any of the code itself** \u2014 only insert docstrings.\n7. Maintain consistent indentation and formatting so docstrings align properly within the code.\n\nCode:\n{\n{{CODE}}\n}",
    "parameters": [
      "CODE"
    ],
    "id": "039cd1de-bbc8-4529-ae09-a1ade618cee9"
  }
]