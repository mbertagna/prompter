[
  {
    "title": "Coding Agent Prompt Creation",
    "description": "A prompt which can be provided to a LLM-based chatbot which has context about a feature to implement. The result of providing this prompt to the chatbot can be passed to a coding agent (e.g., Cursor, Gemini CLI, Claude Code, etc.).",
    "base_prompt": "Your role is to **create a complete, ready-to-use prompt** for a **coding agent** whose job is to implement or integrate a **specific feature or change** into the codebase.\n\nBase this generated prompt entirely on the **most recent feature or change discussed in the conversation**.  \nYour task is to translate that discussion into a clear, structured, and actionable prompt that guides the coding agent through reasoning, planning, and conceptually integrating the feature into the system.\n\nFocus on clarity, precision, and completeness.\n\n---\n\n### 1. Feature Implementation Focus\n\nCurate the prompt so it instructs the coding agent to implement the specified feature or change in the codebase.  \nEmphasize **conceptual clarity** and **architectural integration** across modules or components.  \nThe prompt should tell the coding agent to reason about *how the feature fits into the system*, leaving detailed implementation choices\u2014such as helper functions, naming, or internal logic\u2014open to their discretion.\n\n---\n\n### 2. Required Structure of the Coding Agent\u2019s Response\n\nEnsure the generated prompt tells the coding agent to structure their response using the following format:\n\n#### **1. Feature Overview**\n\nGuide the coding agent to summarize the **purpose, scope, and user value** of the feature or change in clear and concise terms.\n\n#### **2. Conceptual Breakdown of Codebase Changes (Without Code)**\n\nInstruct the coding agent to produce a **high-level conceptual breakdown** of all required codebase changes to integrate the feature.  \nThey should describe the **conceptual roles** of any new or modified classes, methods, or functions and indicate how these interact with existing components in the system.\n\n#### **3. Architectural Alignment and Guidance**\n\nTell the coding agent to provide **architectural guidance** showing how the proposed changes align with the system\u2019s overall design.  \nEmphasize principles of **modularity, clarity, and cohesion**, ensuring each conceptual unit serves a well-defined purpose.\n\n---\n\n### 3. General Coding Style and Deliverables\n\nInclude the following coding standards and deliverable requirements in the generated prompt for the coding agent:\n\n* **Docstrings:** All classes, methods, and functions must include **NumPy-style docstrings** written in clear, concise language.\n* **Comments:** Include comments only where logic is complex or non-obvious.\n* **Modularity:** Each function or method should perform a **single, focused task**.\n* **Emojis:** Exclude emojis from all text.\n\n---\n\n### 4. Context Files\n\nEnsure the generated prompt includes a section listing the files that will be provided to the coding agent for context.  \nUse a placeholder such as:\n\n* [List of all necessary files (e.g., `src/module_a/file.py`, `tests/test_file.py`, etc.)]\n\n---\n\n### 5. Output Expectation\n\nYour final output should be a **fully curated prompt** ready to be given directly to a coding agent.  \nThe generated prompt must be self-contained, unambiguous, and fully informed by the latest feature or change discussed in this conversation.",
    "parameters": [],
    "id": "a9410a06-1b44-4fbc-9e26-9e8426faaa4b"
  },
  {
    "title": "Project Spec Builder",
    "description": "A chatbot prompt which can be used to help create a spec for any software project",
    "base_prompt": "**Idea Overview:**\nI want to build a software project that { {{PROJECT_IDEA}} }.\n\n---\n\n### **Areas to Explore**\n\nBefore creating a detailed specification, I need to understand the following:\n\n* **Purpose and scope** \u2014 what the project should accomplish and who it\u2019s for\n* **Core functionality** \u2014 the main features and capabilities\n* **Technology preferences** \u2014 programming languages, frameworks, tools, or platforms to use\n* **Architecture and infrastructure** \u2014 how components interact, data flow, hosting, and deployment\n* **Integration needs** \u2014 any external systems, APIs, or data sources to connect with\n* **User interaction and interface** \u2014 how users will interact with the system (CLI, GUI, web app, API, etc.)\n* **Performance and scalability** \u2014 expected load, performance goals, and scaling considerations\n* **Security and privacy requirements** \u2014 any specific standards, data protection, or authentication needs\n* **Testing and maintenance** \u2014 expectations for testing, monitoring, or long-term upkeep\n\n---\n\n### **Your Task**\n\n#### **Phase 1: Discovery (Before Building the Specification)**\n\n* Ask **yes/no questions one at a time** to gather information about each of the areas above.\n* **Wait for the user\u2019s response** before asking the next question.\n* Do **not** create or outline the specification yet.\n* When you believe you\u2019ve gathered sufficient details, **propose that you have enough information** and ask the user to confirm before proceeding.\n* Only move to Phase 2 if the user **explicitly agrees** that you have enough information.\n\n#### **Phase 2: Specification (After User Agreement)**\n\n* Create the specification **only after** receiving explicit user confirmation.\n* Do **not** mix questioning with specification writing.\n* Write a **concise, detailed, and structured specification** that accurately reflects all information gathered during Phase 1.\n",
    "parameters": [
      "PROJECT_IDEA"
    ],
    "id": "f3974a6c-3524-4afb-9738-4c1ff01c7f34"
  },
  {
    "title": "Coding Agent Prompt Creation for New Codebase Architecture",
    "description": "",
    "base_prompt": "**Codebase:** { {{CODEBASE}} }\n\n# **Your Goal:** Design a modular, DRY, and scalable organization structure for upcoming feature integrations.\n\n---\n\n### Primary Objective\n\nYou are tasked with proposing **codebase organization options** for [CODEBASE_NAME_PLACEHOLDER] one at a time.\nEach proposal should aim for **maximal modularity, clarity, and architectural consistency** with the presumed or provided structure of the codebase.\n\nAt each iteration:\n\n1. Provide **one** option for organization (not multiple at once).\n2. Wait for my feedback.\n3. If I request changes or refinements, incorporate them into the next iteration.\n4. When I explicitly approve an option, you will then generate a **final implementation prompt** for a coding agent as described below.\n\n---\n\n### Step 1: Iterative Codebase Organization Proposal\n\nEach proposal should include:\n\n#### 1. Conceptual Structure Overview\n\nProvide a **concise conceptual map** of how the system\u2019s architecture and components will be restructured or reorganized.\nExplain the purpose of each new or refactored module, class, or directory and how they fit into the broader design.\n\n#### 2. Key Modules and Responsibilities\n\nList the **key components** (modules, classes, or functions) and describe their **high-level conceptual roles** \u2014 what each does and how they interact \u2014 **without suggesting any specific implementation or code**.\n\n#### 3. Design Rationale\n\nJustify **why** this architectural approach improves modularity, reusability, maintainability, and scalability.\nReference design principles (e.g., SOLID, separation of concerns, dependency inversion) where appropriate.\n\n#### 4. DRYness and Extensibility Check\n\nExplicitly explain how the proposed structure:\n\n* Eliminates redundancy and tight coupling\n* Supports extensibility and maintainability\n* Aligns with or improves upon the codebase\u2019s existing patterns and conventions\n\nAfter presenting this, stop and ask:\n\n> \u201cWould you like to approve this organization or request revisions before proceeding?\u201d\n\n---\n\n### Step 2: Once Approved \u2014 Generate the Implementation Prompt\n\nWhen I approve a structure, you will output the following **final implementation prompt** (filled in appropriately):\n\n---\n\n#### **Implementation Prompt for Coding Agent**\n\n**Prompt:**\n\n> Implement the approved architectural restructuring in the codebase.\n> **Focus on conceptual clarity, structural integrity, and modular organization**, leaving detailed implementation choices and low-level logic (e.g., helper utilities, variable names, or internal optimizations) to your discretion.\n> **Avoid overly specific implementation details** unless they are essential to preserve architectural correctness.\n\nYour response must strictly adhere to the following structure and content requirements:\n\n---\n\n### 1. Architectural Restructure Overview\n\nProvide a **clear and concise conceptual overview** of the architectural restructuring \u2014 its purpose, motivation, and expected impact on the codebase (e.g., improved modularity, maintainability, or scalability).\n\n### 2. Conceptual Breakdown of Changes (Without Code)\n\nProvide a **comprehensive, high-level conceptual breakdown** of the restructuring steps.\nDescribe which components, modules, or directories are being added, removed, or reorganized, and how they interact in the new structure.\n**Avoid suggesting specific code.** Focus on *what* needs to change and *where* it fits conceptually.\n\n### 3. Architectural Alignment and Guidance\n\nOffer **specific, high-level guidance** on how the restructuring aligns with and strengthens the existing architecture (e.g., enforcing separation of concerns, design patterns, or layering principles).\n**Emphasize modularity** \u2014 each module or class should have a single, well-defined purpose.\n\n---\n\n### General Coding Style and Deliverables\n\nAdhere to the following style guidelines in the restructured code:\n\n* **Docstrings:** Use **NumPy docstring format** for all classes, methods, and functions where applicable. Ensure the verbiage is **concise**.\n* **Comments:** **Remove all unnecessary comments.** Only include comments for complex, non-obvious logic if absolutely required for clarity.\n* **Modularity:** Ensure the architecture enforces strong modular boundaries \u2014 each component should perform a **specific, single role**.\n* **Emojis:** Avoid the use of emojis.\n\n---\n\n### Context Files\n\nThe following files will be provided as context for accurate and efficient restructuring:\n\n* [List of all necessary files (e.g., `src/module_a/file.py`, `core/architecture.py`, `tests/test_integration.py`, etc.)]\n\n---\n\n### Step 3: Iterative Refinement (Optional)\n\nIf requested, you may help refine or adapt the generated implementation prompt (e.g., adjusting restructuring scope, architecture focus, or file list) before it is finalized for the coding agent.\n",
    "parameters": [
      "CODEBASE"
    ],
    "id": "b4e84abe-0bbe-48ba-b037-10417ddab48f"
  },
  {
    "title": "Commit Prompt",
    "description": "",
    "base_prompt": "Create a commit message that follows exactly the same format and structure as the provided example.\nUse **simple, clear language** and keep all bullet points short and direct.\nAvoid changing any section headers, indentation, or layout \u2014 your goal is to match the style of the example exactly.\nAvoid using any markdown formatting such as bold text, code blocks, or lists. Use plain text only.\nReturn the final commit message **inside a text box**.\n\nExample commit message:\n{ {{example_commit_message}} }\n\nImplementation summary:\n{ {{implementation_summary}} }\n\nImplementation code:\n{ {{implementation_code}} }\n\nComplete codebase:\n{ {{complete_codebase}} }",
    "parameters": [
      "example_commit_message",
      "implementation_summary",
      "implementation_code",
      "complete_codebase"
    ],
    "id": "2f3eda1a-48f8-460a-b9e7-3b1801c1df0b"
  },
  {
    "title": "Atomic Git History Generation (Interactive)",
    "description": "A three-stage, approval-gated workflow to transform a single, large code change (before/after diff) into a clean, logical set of atomic commits organized across ordered topic branches. This strategy supports a clean, rebasable dependency tree.",
    "base_prompt": "I have made changes to the **{{TOPIC}}** project. My goal is to organize these changes into a clean, logical set of **atomic Git commits** across multiple **topic branches** for a final push.\n\nYour process will consist of three distinct tasks, each requiring my approval before proceeding to the next.\n\n### Task 1: Code Difference Analysis\n\n1.  **Analyze the changes:** Review the `CODE_BEFORE` and `CODE_AFTER` sections to understand the exact differences in the codebase.\n2.  **Report findings:** Summarize the nature and scope of the changes (e.g., \"Feature X added,\" \"Refactoring of Y module,\" \"Bug Z fixed\").\n3.  **Output:** Present a summary of the differences.\n      * **STOP:** Wait for my approval before proceeding to Task 2. I may ask for revisions or clarifications at this stage.\n\n-----\n\n### Task 2: High-Level Git Organization\n\n  * *This task proceeds only after my approval of Task 1.*\n\n1.  **Determine topics:** Group the changes identified in Task 1 into logical, high-level **topic branches** (e.g., `feature/user-auth`, `refactor/api-cleanup`).\n2.  **Establish ordering:** Decide on the most logical and narrative **ordering** for these topic branches, ensuring a clean dependency tree where each branch builds on the previous one.\n3.  **Output:** Provide a numbered list of the proposed topic branches and their intended order.\n      * **STOP:** Wait for my approval before proceeding to Task 3. I may ask for revisions to the branch structure or ordering.\n\n-----\n\n### Task 3: Atomic Commit Generation\n\n  * *This task proceeds only after my approval of Task 2.*\n\n1.  **Generate atomic commits:** For each approved topic branch, break down the changes into the smallest possible **atomic commits**. The commits must be ordered to tell a clear, logical story.\n2.  **Format the output:** For each generated atomic commit, present two items:\n      * A **one-line commit summary** (max 50 characters).\n      * A list of the specific **files or code snippets** to be included in that commit (i.e., the diff to be staged). Clearly indicate which topic branch the commit belongs to.\n3.  **Dependency Note:** I will be rebasing each successive new topic branch onto the previous one. The commit structure *must* support this clean, sequential dependency tree.\n\n-----\n\n## Code Base\n\nCODE BEFORE:\n{ {{CODE_BEFORE}} }\n\nCODE AFTER:\n{ {{CODE_AFTER}} }",
    "parameters": [
      "TOPIC",
      "CODE_BEFORE",
      "CODE_AFTER"
    ],
    "id": "f22f36c0-f0c7-4d82-ac9a-c474e6afcfec"
  },
  {
    "title": "Add NumPy-Style Docstrings Without Modifying Code",
    "description": "",
    "base_prompt": "Add complete and correct NumPy-style docstrings to the provided code.\n\nFollow these exact rules carefully:\n\n1. **File-level docstring:** At the very top of each file, include a brief description of the file\u2019s purpose, main classes/functions, and any important usage notes.\n2. **Class docstrings:** Describe what the class represents, its main attributes, and its intended use. Include an **Attributes** section listing all key attributes and their types.\n3. **Function and method docstrings:** Include the following NumPy-style sections where applicable:\n   * **Parameters:** List every parameter, its type, and a short, clear explanation.\n   * **Returns:** Describe the return value(s) and their types.\n   * **Raises:** List possible exceptions, if any.\n   * **Examples:** Add a simple example only if it helps clarify functionality.\n4. Use **simple, direct, and concise** language throughout.\n5. **Avoid emojis** and unnecessary phrasing.\n6. **Avoid changing any of the code itself** \u2014 only insert docstrings.\n7. Maintain consistent indentation and formatting so docstrings align properly within the code.\n\nCode:\n{\n{{CODE}}\n}",
    "parameters": [
      "CODE"
    ],
    "id": "039cd1de-bbc8-4529-ae09-a1ade618cee9"
  }
]